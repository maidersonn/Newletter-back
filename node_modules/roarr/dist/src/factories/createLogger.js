"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = void 0;
const fast_printf_1 = require("fast-printf");
const globalthis_1 = __importDefault(require("globalthis"));
const is_circular_1 = __importDefault(require("is-circular"));
const json_stringify_safe_1 = __importDefault(require("json-stringify-safe"));
const config_1 = require("../config");
const constants_1 = require("../constants");
let loggedWarning = false;
const globalThis = (0, globalthis_1.default)();
const getAsyncLocalContext = () => {
    var _a;
    const asyncLocalStorage = globalThis.ROARR.asyncLocalStorage;
    if (!asyncLocalStorage) {
        return {};
    }
    return ((_a = asyncLocalStorage.getStore()) === null || _a === void 0 ? void 0 : _a.context) || {};
};
const getSequence = () => {
    const asyncLocalStorage = globalThis.ROARR.asyncLocalStorage;
    if (!asyncLocalStorage) {
        return String(globalThis.ROARR.sequence++);
    }
    const store = asyncLocalStorage.getStore();
    if ((store === null || store === void 0 ? void 0 : store.sequenceRoot) !== undefined && (store === null || store === void 0 ? void 0 : store.sequence) !== undefined) {
        return String(store.sequenceRoot) + '.' + String(store.sequence++);
    }
    return String(globalThis.ROARR.sequence++);
};
const defaultContext = {};
const createLogger = (onMessage, parentContext) => {
    const log = (a, b, c, d, e, f, g, h, i, j) => {
        const time = Date.now();
        const sequence = getSequence();
        const asyncLocalStorage = globalThis.ROARR.asyncLocalStorage;
        let context;
        let message;
        if (typeof a === 'string') {
            if (asyncLocalStorage) {
                context = {
                    ...getAsyncLocalContext(),
                    ...parentContext,
                };
            }
            else {
                context = parentContext !== null && parentContext !== void 0 ? parentContext : defaultContext;
            }
        }
        else {
            context = {
                ...getAsyncLocalContext(),
                ...parentContext,
                ...a,
            };
        }
        if (context !== defaultContext && (0, is_circular_1.default)(context)) {
            context = JSON.parse((0, json_stringify_safe_1.default)(context));
        }
        if (typeof a === 'string' && b === undefined) {
            message = a;
        }
        else if (typeof a === 'string') {
            message = (0, fast_printf_1.printf)(a, b, c, d, e, f, g, h, i, j);
        }
        else {
            if (typeof b !== 'string') {
                throw new TypeError('Message must be a string. Received ' + typeof b + '.');
            }
            message = (0, fast_printf_1.printf)(b, c, d, e, f, g, h, i, j);
        }
        onMessage({
            context,
            message,
            sequence,
            time,
            version: config_1.ROARR_LOG_FORMAT_VERSION,
        });
    };
    log.child = (context) => {
        if (typeof context === 'function') {
            return (0, exports.createLogger)((message) => {
                const nextMessage = context(message);
                if (typeof nextMessage !== 'object' || nextMessage === null) {
                    throw new Error('Child middleware function must return a message object.');
                }
                onMessage(nextMessage);
            }, parentContext);
        }
        return (0, exports.createLogger)(onMessage, {
            ...getAsyncLocalContext(),
            ...parentContext,
            ...context,
        });
    };
    log.getContext = () => {
        return {
            ...getAsyncLocalContext(),
            ...parentContext !== null && parentContext !== void 0 ? parentContext : defaultContext,
        };
    };
    log.adopt = async (routine, context) => {
        const asyncLocalStorage = globalThis.ROARR.asyncLocalStorage;
        if (!asyncLocalStorage) {
            if (loggedWarning === false) {
                loggedWarning = true;
                onMessage({
                    context: {
                        logLevel: constants_1.logLevels.warn,
                        package: 'roarr',
                    },
                    message: 'async_hooks are unavailable; Roarr.child will not function as expected',
                    sequence: getSequence(),
                    time: Date.now(),
                    version: config_1.ROARR_LOG_FORMAT_VERSION,
                });
            }
            return routine();
        }
        const store = asyncLocalStorage.getStore();
        let sequenceRoot;
        if ((store === null || store === void 0 ? void 0 : store.sequenceRoot) !== undefined && (store === null || store === void 0 ? void 0 : store.sequence) !== undefined) {
            sequenceRoot = String(store.sequenceRoot) + '.' + String(store.sequence++);
        }
        else {
            sequenceRoot = String(globalThis.ROARR.sequence++);
        }
        return asyncLocalStorage.run({
            context: {
                ...store === null || store === void 0 ? void 0 : store.context,
                ...context,
            },
            sequence: 0,
            sequenceRoot,
        }, () => {
            return routine();
        });
    };
    log.trace = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.trace,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    log.debug = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.debug,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    log.info = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.info,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    log.warn = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.warn,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    log.error = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.error,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    log.fatal = (a, b, c, d, e, f, g, h, i, j) => {
        log.child({
            logLevel: constants_1.logLevels.fatal,
        })(a, b, c, d, e, f, g, h, i, j);
    };
    return log;
};
exports.createLogger = createLogger;
